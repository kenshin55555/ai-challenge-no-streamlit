# -*- coding: utf-8 -*-
"""
main.py

DESCRIPTION:
  This script serves as the primary backend for the Stocktrader Agent application.
  It uses FastAPI to create a web server that handles:
  - Serving the static frontend files (index.html, JS, CSS).
  - Managing WebSocket connections for real-time, bidirectional communication
    with the client.
  - Interfacing with the Google ADK (Agent Development Kit) to run the
    conversational AI agent (`root_agent`).

ARCHITECTURE:
  - A FastAPI web application is created.
  - A static file mount serves the frontend from the './static' directory.
  - A WebSocket endpoint at '/ws/{user_id}' handles all client communication.
  - For each connected client, two asynchronous tasks are created:
    1. `agent_to_client_messaging`: Streams the agent's responses to the client.
    2. `client_to_agent_messaging`: Sends the user's messages to the agent.
  - A helper function, `parse_markdown_to_json`, is used to extract structured
    data from the agent's final Markdown report to populate the UI's analysis view.
"""
import asyncio
import json
import logging
import os
import re
import warnings
from datetime import datetime
from pathlib import Path

from dotenv import load_dotenv
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles

from google.adk.agents import LiveRequestQueue
from google.adk.agents.run_config import RunConfig
from google.adk.runners import InMemoryRunner
from google.genai.types import Content, Part

from stocks_agent.agent import root_agent

# ==============================================================================
# Setup & Configuration
# ==============================================================================
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(name)s - %(message)s'
)

warnings.filterwarnings("ignore", category=UserWarning, module="pydantic")
load_dotenv()

APP_NAME = "ADK Stocktrader Agent"
STATIC_DIR = Path(__file__).parent / "static"


# ==============================================================================
# Helper Functions
# ==============================================================================
def parse_markdown_to_json(markdown_text: str) -> dict:
    """Parses the agent's Markdown report into a structured JSON object.

    This function uses regular expressions to find and extract specific data
    points (title, confidence score, confirmations, contradictions) from the
    free-text Markdown output and formats them into a dictionary that the
    frontend can easily consume.

    Args:
        markdown_text: The raw Markdown string generated by the agent.

    Returns:
        A dictionary containing the structured analysis data.
    """
    data = {
        "title": "Analysis Report",
        "date": datetime.now().strftime("%m/%d/%Y %H:%M"),
        "confidenceScore": 0,
        "contradictionsCount": 0,
        "confirmationsCount": 0,
        "contradictions": [],
        "confirmations": []
    }

    try:
        title_match = re.search(r"\*\*Hypothesis Evaluation:\*\*\s*(.*)", markdown_text)
        if title_match:
            data["title"] = f"Hypothesis Evaluation: {title_match.group(1).strip()}"

        score_match = re.search(r"\*\*Confidence Score:\*\*\s*(\d+)%", markdown_text)
        if score_match:
            data["confidenceScore"] = int(score_match.group(1))

        confirmations_text = re.search(
            r"\*\*Key Confirmations \(Supporting Evidence\):\*\*\n(.*?)\n\*\*Key Contradictions",
            markdown_text, re.DOTALL
        )
        if confirmations_text:
            confirmations = re.findall(r"\*\s*(.*)", confirmations_text.group(1))
            data["confirmationsCount"] = len(confirmations)
            data["confirmations"] = [
                {"text": c.strip(), "analysis": "Sourced from agent report.", "level": "Info"}
                for c in confirmations
            ]

        contradictions_text = re.search(
            r"\*\*Key Contradictions \(Risk Factors\):\*\*\n(.*?)\n\*\*Actionable Recommendation",
            markdown_text, re.DOTALL
        )
        if contradictions_text:
            contradictions = re.findall(r"\*\s*(.*)", contradictions_text.group(1))
            data["contradictionsCount"] = len(contradictions)
            data["contradictions"] = [
                {"text": c.strip(), "analysis": "Sourced from agent report.", "level": "Warning"}
                for c in contradictions
            ]

    except Exception as e:
        logging.error(f"Error parsing Markdown to JSON: {e}")

    return data


# ==============================================================================
# ADK Agent Session Management
# ==============================================================================
async def start_agent_session(user_id: str):
    """Initializes an ADK agent session for a given user.

    Args:
        user_id: A unique identifier for the user session.

    Returns:
        A tuple containing the live events iterator and the request queue for
        the agent session.
    """
    runner = InMemoryRunner(app_name=APP_NAME, agent=root_agent)
    session = await runner.session_service.create_session(app_name=APP_NAME, user_id=user_id)
    run_config = RunConfig(response_modalities=["TEXT"])
    live_request_queue = LiveRequestQueue()
    loop = asyncio.get_running_loop()

    live_events_iterator = await loop.run_in_executor(
        None,
        lambda: runner.run_live(
            session=session,
            live_request_queue=live_request_queue,
            run_config=run_config,
        )
    )
    return live_events_iterator, live_request_queue


# ==============================================================================
# WebSocket Communication Handlers
# ==============================================================================
async def agent_to_client_messaging(websocket: WebSocket, live_events):
    """Streams messages from the agent to the client via WebSocket.

    This function iterates through events from the ADK agent. It streams
    partial text responses for a "live typing" effect. When the agent's turn
    is complete, it sends the full Markdown text to the chat and also sends a
    parsed JSON version to populate the analysis view.

    Args:
        websocket: The WebSocket connection object for the client.
        live_events: The asynchronous iterator for agent events.
    """
    full_response_text = ""
    try:
        async for event in live_events:
            if event.partial and event.content and event.content.parts:
                for part in event.content.parts:
                    if part.text:
                        full_response_text += part.text
                        message = {"mime_type": "text/plain", "data": part.text}
                        await websocket.send_text(json.dumps(message))

            if event.turn_complete:
                logging.debug("[SERVER]: Turn complete signal received.")
                if full_response_text:
                    logging.debug(f"Full response to parse: {full_response_text}")
                    analysis_json = parse_markdown_to_json(full_response_text)
                    json_message = {"mime_type": "application/json", "data": analysis_json}
                    await websocket.send_text(json.dumps(json_message))
                    logging.debug("[SERVER]: Sent structured JSON for analysis view.")
                    full_response_text = ""  # Reset for the next turn.

                await websocket.send_text(json.dumps({"turn_complete": True}))
                logging.debug("[SERVER]: Sent turn_complete signal to UI.")

            elif event.interrupted:
                await websocket.send_text(json.dumps({"interrupted": True}))
                logging.debug("[AGENT TO CLIENT]: Interrupted")

    except WebSocketDisconnect:
        logging.info("Client closed the connection.")
    except Exception as e:
        logging.error(f"Error in agent-to-client messaging: {e}")
    finally:
        logging.info("Agent to client messaging task finished.")


async def client_to_agent_messaging(websocket: WebSocket, live_request_queue: LiveRequestQueue):
    """Receives messages from the client and sends them to the agent.

    Args:
        websocket: The WebSocket connection object for the client.
        live_request_queue: The queue to send user messages to the agent.
    """
    try:
        while True:
            message_json = await websocket.receive_text()
            message = json.loads(message_json)
            if message["mime_type"] == "text/plain":
                content = Content(role="user", parts=[Part.from_text(text=message["data"])])
                live_request_queue.send_content(content=content)
                logging.debug(f"[CLIENT TO AGENT]: {message['data']}")
    except WebSocketDisconnect:
        logging.info("Client disconnected.")
    except Exception as e:
        logging.error(f"Error in client-to-agent messaging: {e}")
    finally:
        live_request_queue.close()
        logging.info("Client to agent messaging task finished.")


# ==============================================================================
# FastAPI Application Setup
# ==============================================================================
app = FastAPI()
app.mount("/static", StaticFiles(directory=STATIC_DIR), name="static")


@app.get("/")
async def root():
    """Serves the main index.html file."""
    return FileResponse(os.path.join(STATIC_DIR, "index.html"))


@app.websocket("/ws/{user_id}")
async def websocket_endpoint(websocket: WebSocket, user_id: int):
    """Handles new WebSocket connections from clients.

    This function accepts a new connection, starts an ADK agent session, and
    spawns two concurrent tasks to handle bidirectional communication between
    the agent and the client.

    Args:
        websocket: The WebSocket connection object for the new client.
        user_id: A unique ID for the client session.
    """
    await websocket.accept()
    logging.info(f"Client #{user_id} connected.")
    try:
        live_events, live_request_queue = await start_agent_session(str(user_id))

        agent_to_client_task = asyncio.create_task(
            agent_to_client_messaging(websocket, live_events)
        )
        client_to_agent_task = asyncio.create_task(
            client_to_agent_messaging(websocket, live_request_queue)
        )

        done, pending = await asyncio.wait(
            [client_to_agent_task, agent_to_client_task],
            return_when=asyncio.FIRST_COMPLETED,
        )
        for task in pending:
            task.cancel()

    except Exception as e:
        logging.error(f"An error occurred in the websocket endpoint: {e}")
    finally:
        logging.info(f"Client #{user_id} disconnected")